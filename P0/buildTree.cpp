// Name: Trevor Parsons
// Date: 9/22/19
// Description: Function definitions used to build the BST from file input

#include "buildTree.h"
#include "node.h"
#include <fstream>
#include <vector>
#include <string>

using namespace std;

// Note that the stucture of the BST generated by the funcctions in this file
// use the node_t structure (defined in "node.h:. The "key" value for each node 
// is  a letter, and all words that are present in the input file that start 
// with that letter are stored in the corresponding node's "words" variable.

// Function for building the BST
struct node_t* buildTree(fstream& inputFile) {
	string next;

	inputFile >> next;

	struct node_t *root = createNode(next);

	while (inputFile >> next) {
		// Check if a node with the first letter of "next" has been made already
		if (treeSearch(root, next[0]) == NULL) {
			insertNode(root, next);
		}
		else {
			treeSearch(root, next[0])->words.push_back(next);
		}
	}

	return root;
}

// function for generating a new BST node
struct node_t* createNode(string word) {
	node_t *nodePtr = new node_t();
	(*nodePtr).words.push_back(word);
	(*nodePtr).key = word[0];
	(*nodePtr).left = NULL;
	(*nodePtr).right = NULL;

	return nodePtr;
}

// Function for inserting a node into the BST
struct node_t* insertNode(struct node_t* root, string word) {
	if (root == NULL) return createNode(word);

	if (word[0] < root->key)
		root->left = insertNode(root->left, word);
	else if (word[0] > root->key)
		root->right = insertNode(root->right, word);

	return root;
}

// Function for searching the tree for a specific key value (letter)
struct node_t* treeSearch(node_t *root, char key) {
	if (root == NULL || root->key == key)
		return root;

	if (root->key < key) {
		return treeSearch(root->right, key);
	}

	if (root->key > key) {
		return treeSearch(root->left, key);
	}
}

